<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Webcam Viewer mit Pose-Erkennung</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/pose-detection"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        button {
            padding: 10px 20px;
            background: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }
        button:hover {
            background: #0055aa;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin: 40px 0;
        }
        #stopButton {
            background: #cc0000;
        }
        #stopButton:hover {
            background: #aa0000;
        }
        #poseButton {
            background: #00aa00;
        }
        #poseButton:hover {
            background: #008800;
        }
        select {
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        #output {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
        .container {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin: 0 auto;
            max-width: 1320px;
            gap: 40px;
        }
        .video-container, .avatar-container {
            position: relative;
            width: 640px;
            height: 480px;
            flex: 0 0 auto;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .video-container {
            background: #000;
        }
        .avatar-container {
            background: #222;
        }
        #avatarCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <h1>Webcam Viewer mit Pose-Erkennung</h1>
    <div class="container">
        <div class="video-container">
            <video id="video" autoplay playsinline></video>
            <canvas id="output"></canvas>
        </div>
        <div class="avatar-container">
            <canvas id="avatarCanvas"></canvas>
        </div>
    </div>
    <div class="button-group">
        <button id="startButton">Start Webcam</button>
        <button id="stopButton" disabled>Stop Webcam</button>
        <button id="poseButton" disabled>Pose-Erkennung</button>
        <select id="modelSelect" disabled>
            <option value="movenet">MoveNet</option>
            <option value="blazepose">BlazePose</option>
        </select>
    </div>
    
    <script>
        let currentStream = null;
        let poseDetectionActive = false;
        let detector = null;
        let animationFrameId = null;
        
        const video = document.getElementById('video');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const poseButton = document.getElementById('poseButton');
        const modelSelect = document.getElementById('modelSelect');
        const outputCanvas = document.getElementById('output');
        const ctx = outputCanvas.getContext('2d');
        const avatarCanvas = document.getElementById('avatarCanvas');
        const avatarCtx = avatarCanvas.getContext('2d');
        
        // Initialize avatar canvas
        avatarCanvas.width = 640;
        avatarCanvas.height = 480;

        // Initialize output canvas
        outputCanvas.width = 640;
        outputCanvas.height = 480;

        async function setupPoseDetection() {
            await tf.ready();
            const model = poseDetection.SupportedModels.MoveNet;
            const detectorConfig = {
                modelType: poseDetection.movenet.modelType.SINGLEPOSE_THUNDER
            };
            detector = await poseDetection.createDetector(model, detectorConfig);
        }

        async function detectPose() {
            if (!poseDetectionActive || !detector) return;
            
            const poses = await detector.estimatePoses(video);
            drawPoses(poses);
            
            animationFrameId = requestAnimationFrame(detectPose);
        }

        function drawPoses(poses) {
            ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            avatarCtx.clearRect(0, 0, avatarCanvas.width, avatarCanvas.height);
            
            if (poses && poses.length > 0) {
                const keypoints = poses[0].keypoints;
                
                // Draw keypoints on webcam
                keypoints.forEach(keypoint => {
                    if (keypoint.score > 0.3) {
                        ctx.beginPath();
                        ctx.arc(keypoint.x, keypoint.y, 5, 0, 2 * Math.PI);
                        ctx.fillStyle = 'red';
                        ctx.fill();
                    }
                });
                
                // Draw skeleton on webcam
                const connections = poseDetection.util.getAdjacentPairs(poseDetection.SupportedModels.MoveNet);
                connections.forEach(([i, j]) => {
                    const kp1 = keypoints[i];
                    const kp2 = keypoints[j];
                    if (kp1.score > 0.3 && kp2.score > 0.3) {
                        ctx.beginPath();
                        ctx.moveTo(kp1.x, kp1.y);
                        ctx.lineTo(kp2.x, kp2.y);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = 'white';
                        ctx.stroke();
                    }
                });
                
                // Draw avatar
                drawAvatar(keypoints);
            }
        }
        
        function drawAvatar(keypoints) {
            const scale = 1.5;
            const offsetX = 320;
            const offsetY = 240;
            
            // Find keypoints
            const nose = keypoints.find(k => k.name === 'nose');
            const leftShoulder = keypoints.find(k => k.name === 'left_shoulder');
            const rightShoulder = keypoints.find(k => k.name === 'right_shoulder');
            const leftElbow = keypoints.find(k => k.name === 'left_elbow');
            const rightElbow = keypoints.find(k => k.name === 'right_elbow');
            const leftWrist = keypoints.find(k => k.name === 'left_wrist');
            const rightWrist = keypoints.find(k => k.name === 'right_wrist');
            const leftHip = keypoints.find(k => k.name === 'left_hip');
            const rightHip = keypoints.find(k => k.name === 'right_hip');
            const leftKnee = keypoints.find(k => k.name === 'left_knee');
            const rightKnee = keypoints.find(k => k.name === 'right_knee');
            const leftAnkle = keypoints.find(k => k.name === 'left_ankle');
            const rightAnkle = keypoints.find(k => k.name === 'right_ankle');
            
            if (nose && leftShoulder && rightShoulder && 
                leftHip && rightHip && leftShoulder.score > 0.3 && 
                rightShoulder.score > 0.3) {
                
                // Head with baseball cap
                avatarCtx.beginPath();
                avatarCtx.arc(
                    offsetX + (nose.x - 320) * scale, 
                    offsetY + (nose.y - 240) * scale, 
                    25, 0, 2 * Math.PI
                );
                avatarCtx.fillStyle = '#FFD700'; // Gold for skin tone
                avatarCtx.fill();
                
                // Cap
                avatarCtx.beginPath();
                avatarCtx.moveTo(
                    offsetX + (nose.x - 320 - 30) * scale,
                    offsetY + (nose.y - 240 - 15) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (nose.x - 320 + 30) * scale,
                    offsetY + (nose.y - 240 - 15) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (nose.x - 320 + 20) * scale,
                    offsetY + (nose.y - 240 - 30) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (nose.x - 320 - 20) * scale,
                    offsetY + (nose.y - 240 - 30) * scale
                );
                avatarCtx.closePath();
                avatarCtx.fillStyle = '#FF0000'; // Red cap
                avatarCtx.fill();
                
                // Whistle (around neck)
                avatarCtx.beginPath();
                avatarCtx.arc(
                    offsetX + (nose.x - 320) * scale,
                    offsetY + (nose.y - 240 + 35) * scale,
                    8, 0, 2 * Math.PI
                );
                avatarCtx.fillStyle = '#FFFFFF';
                avatarCtx.fill();
                
                // Torso (t-shirt)
                avatarCtx.beginPath();
                avatarCtx.moveTo(
                    offsetX + (leftShoulder.x - 320) * scale,
                    offsetY + (leftShoulder.y - 240) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (rightShoulder.x - 320) * scale,
                    offsetY + (rightShoulder.y - 240) * scale
                );
                avatarCtx.lineTo(
                    offsetX + ((leftHip.x + rightHip.x)/2 - 320) * scale,
                    offsetY + ((leftHip.y + rightHip.y)/2 - 240) * scale
                );
                avatarCtx.closePath();
                avatarCtx.fillStyle = '#0000FF'; // Blue shirt
                avatarCtx.fill();
                
                // Shorts
                avatarCtx.beginPath();
                avatarCtx.moveTo(
                    offsetX + (leftHip.x - 320) * scale,
                    offsetY + (leftHip.y - 240) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (rightHip.x - 320) * scale,
                    offsetY + (rightHip.y - 240) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (rightHip.x - 320 - 15) * scale,
                    offsetY + (rightHip.y - 240 + 40) * scale
                );
                avatarCtx.lineTo(
                    offsetX + (leftHip.x - 320 + 15) * scale,
                    offsetY + (leftHip.y - 240 + 40) * scale
                );
                avatarCtx.closePath();
                avatarCtx.fillStyle = '#FFFFFF'; // White shorts
                avatarCtx.fill();
                
                // Arms and legs with sporty look
                if (leftShoulder && leftElbow && leftWrist) {
                    drawLimb(leftShoulder, leftElbow, leftWrist, '#FFD700', 8); // Skin tone
                }
                if (rightShoulder && rightElbow && rightWrist) {
                    drawLimb(rightShoulder, rightElbow, rightWrist, '#FFD700', 8);
                }
                if (leftHip && leftKnee && leftAnkle) {
                    drawLimb(leftHip, leftKnee, leftAnkle, '#FFD700', 10); // Thicker legs
                }
                if (rightHip && rightKnee && rightAnkle) {
                    drawLimb(rightHip, rightKnee, rightAnkle, '#FFD700', 10);
                }
            }
            
            function drawLimb(joint1, joint2, joint3, color, width) {
                if (joint1.score > 0.3 && joint2.score > 0.3 && joint3.score > 0.3) {
                    avatarCtx.beginPath();
                    avatarCtx.moveTo(
                        offsetX + (joint1.x - 320) * scale,
                        offsetY + (joint1.y - 240) * scale
                    );
                    avatarCtx.lineTo(
                        offsetX + (joint2.x - 320) * scale,
                        offsetY + (joint2.y - 240) * scale
                    );
                    avatarCtx.lineTo(
                        offsetX + (joint3.x - 320) * scale,
                        offsetY + (joint3.y - 240) * scale
                    );
                    avatarCtx.lineWidth = width;
                    avatarCtx.strokeStyle = color;
                    avatarCtx.stroke();
                }
            }
        }

        // Clientseitige Webcam-Initialisierung
        async function initWebcam() {
            try {
                currentStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { width: 640, height: 480 },
                    audio: false 
                });
                video.srcObject = currentStream;
                return true;
            } catch (err) {
                console.error('Webcam error:', err);
                alert('Webcam-Zugriff fehlgeschlagen: ' + err.message);
                return false;
            }
        }

        startButton.addEventListener('click', async () => {
            const success = await initWebcam();
            if (!success) return;
            
            try {
                startButton.textContent = 'Webcam läuft';
                startButton.disabled = true;
                stopButton.disabled = false;
                poseButton.disabled = false;
                modelSelect.disabled = false;
                
                await setupPoseDetection();
            } catch (err) {
                console.error('Error:', err);
                alert('Fehler: ' + err.message);
            }
        });

        stopButton.addEventListener('click', () => {
            if (currentStream) {
                currentStream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                startButton.disabled = false;
                stopButton.disabled = true;
                poseButton.disabled = true;
                modelSelect.disabled = true;
                startButton.textContent = 'Start Webcam';
                
                if (poseDetectionActive) {
                    togglePoseDetection();
                }
            }
        });

        poseButton.addEventListener('click', togglePoseDetection);

        function togglePoseDetection() {
            poseDetectionActive = !poseDetectionActive;
            
            if (poseDetectionActive) {
                poseButton.textContent = 'Pose stoppen';
                detectPose();
            } else {
                poseButton.textContent = 'Pose-Erkennung';
                cancelAnimationFrame(animationFrameId);
                ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
            }
        }

        modelSelect.addEventListener('change', async () => {
            if (poseDetectionActive) {
                togglePoseDetection();
            }
            await setupPoseDetection();
        });
    </script>
</body>
</html>
